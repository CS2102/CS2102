// Brett Ammeson, Joshua Keller, and Thomas Sellie-Lund

1. We require isValid by including it in the Score interface, which every Score
implements. That way each Score implementation class needs to provide an isValid() method.

2. Yes, it captures this by having SoccerContestant and TennisContestant implement
the Ranked interface.

3. No, it did not. We could have used this assumption by setting up an if statement, where if
it were a valid tournament, the matchesPlayed would be the number of rounds left after the
first occurrence of the name, since the match tree is traversed from the top down. This would
be possible since the player in that round must have advanced from each of the previous rounds.

4. No, it does not. That would require making sure both had been instantiated from the same
implementing class of the Ranked interface, which would mean comparing their class objects.
This was used in the tourValid() method to make sure all Contestants were playing the same 
sport, however. Here as long as they are Ranked, the method compares them according to rank.

5. The tourValid() method uses a helper function playersAlwaysAdvanced(), which checks the other
condition necessary for a tournament to be valid. The ranked condition code is only executed if
the Contestants in the Tournament are Ranked contestants.

6. The initial class/interface setup seems clean, but the Contestant, Team, and Ranked interfaces
are a problem. They force an instanceof test followed by a cast to make sure ranked tournaments
are valid. It would be nice if a Java guru suggested a better design that would allow Java to 
dispatch the ranked condition for tournaments to a helper method when necessary, based on type.